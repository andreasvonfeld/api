product-api/
‚îú‚îÄ‚îÄ node_modules/
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ server.js               # Point d'entr√©e de l'application
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ db.js               # Configuration de la base de donn√©es
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îî‚îÄ‚îÄ Product.js          # Sch√©ma Mongoose pour le produit
‚îî‚îÄ‚îÄ routes/
    ‚îî‚îÄ‚îÄ productRoutes.js    # D√©finition des routes de l'API



    Parfait \! Passer √† **Prisma** avec **PostgreSQL** est un excellent choix pour une API REST moderne, car cela apporte de la robustesse et une meilleure gestion des types (id√©al si vous pr√©voyez d'utiliser TypeScript, mais nous allons rester en JavaScript pour l'instant).

Voici comment adapter la structure pr√©c√©dente pour utiliser **Express**, **Prisma**, et **MySQL**.

## 1\. Initialisation et Installation

1.  **Cr√©ez et initialisez le projet** (si ce n'est pas d√©j√† fait) :

    ```bash
    npm init -y
    ```

2.  **Installez les d√©pendances principales** :

    ```bash
    npm install express dotenv @prisma/client
    ```

3.  **Installez Prisma CLI comme d√©pendance de d√©veloppement** :

    ```bash
    npm install -D prisma
    ```

-----

## 2\. Configuration de MySQL et Prisma

### a. Configuration de la Base de Donn√©es

1.  **Cr√©ez un fichier `.env`** pour d√©finir l'URI de connexion √† votre base de donn√©es MySQL :

    ```
    # Remplacez les valeurs par les v√¥tres
    DATABASE_URL="mysql://root:@localhost:3306/products"
    PORT=5000
    ```

2.  **Initialisez Prisma** :

    ```bash
    npx prisma init
    ```

    Cette commande cr√©e le dossier `prisma` et le fichier `prisma/schema.prisma`. Elle configure automatiquement le `provider` √† `mysql`.

### b. D√©finition du Sch√©ma de Produit

Dans le fichier `prisma/schema.prisma`, d√©finissez votre mod√®le `Product` :

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// Mod√®le Produit
model Product {
  id             Int     @id @default(autoincrement()) // Cl√© primaire auto-incr√©ment√©e
  name           String  @unique // Nom unique
  description    String? // Description optionnelle (utilise String?)
  price          Float   // Prix (utilise Float ou Decimal)
  countInStock   Int     @default(0) // Quantit√© en stock
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String
  role      String   @default("USER")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

### c. Migration de la Base de Donn√©es

Appliquez le sch√©ma √† votre base de donn√©es MySQL :

```bash
npx prisma migrate dev --name init_products_table
```

-----

## 3\. Configuration du Client Prisma

Nous allons cr√©er un client Prisma r√©utilisable pour toute l'application.

Dans `config/prismaClient.js` (ou directement dans le point d'entr√©e pour la simplicit√©) :

```javascript
const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

module.exports = prisma;
```

-----

## 4\. Contr√¥leurs CRUD (Logique M√©tier)

Cr√©ez un fichier `controllers/productController.js` pour la logique CRUD. Nous utiliserons le client Prisma (`prisma`).

```javascript
const prisma = require('../config/prismaClient'); // Le client configur√©

// --- CREATE ---
// @route   POST /api/products
exports.createProduct = async (req, res) => {
  try {
    const { name, description, price, countInStock } = req.body;
    const product = await prisma.product.create({
      data: {
        name,
        description,
        price: parseFloat(price), // Assurez-vous que le prix est un nombre
        countInStock: parseInt(countInStock) || 0,
      },
    });
    res.status(201).json(product);
  } catch (error) {
    // 400 Bad Request ou 409 Conflict (si 'name' est unique)
    res.status(400).json({ message: 'Erreur lors de la cr√©ation du produit.', error: error.message });
  }
};

// --- READ ALL ---
// @route   GET /api/products
exports.getProducts = async (req, res) => {
  try {
    const products = await prisma.product.findMany();
    res.status(200).json(products);
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des produits.' });
  }
};

// --- READ ONE ---
// @route   GET /api/products/:id
exports.getProductById = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    const product = await prisma.product.findUnique({
      where: { id },
    });
    if (product) {
      res.status(200).json(product);
    } else {
      res.status(404).json({ message: 'Produit non trouv√©.' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Erreur serveur.' });
  }
};

// --- UPDATE ---
// @route   PUT /api/products/:id
exports.updateProduct = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    // On ne met √† jour que les champs fournis dans req.body
    const product = await prisma.product.update({
      where: { id },
      data: req.body,
    });
    res.status(200).json(product);
  } catch (error) {
    // G√©rer 404 si l'ID n'existe pas ou 400 si les donn√©es sont invalides
    res.status(400).json({ message: 'Erreur lors de la mise √† jour du produit.', error: error.message });
  }
};

// --- DELETE ---
// @route   DELETE /api/products/:id
exports.deleteProduct = async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    await prisma.product.delete({
      where: { id },
    });
    res.status(204).send(); // 204 No Content est standard pour une suppression r√©ussie sans corps de r√©ponse
  } catch (error) {
    res.status(404).json({ message: 'Produit non trouv√© ou erreur de suppression.', error: error.message });
  }
};
```

-----

## 5\. Routes et Serveur

### a. D√©finition des Routes

Le fichier `routes/productRoutes.js` reste le m√™me que dans l'exemple Mongoose, mais il utilise le nouveau contr√¥leur :

```javascript
const express = require('express');
const router = express.Router();
const productController = require('../controllers/productController');

// Route pour lister TOUS les produits et pour CREER un nouveau produit
router.route('/').get(productController.getProducts).post(productController.createProduct);

// Route pour obtenir, mettre √† jour, et supprimer un produit par ID
router
  .route('/:id')
  .get(productController.getProductById)
  .put(productController.updateProduct)
  .delete(productController.deleteProduct);

module.exports = router;
```

### b. Fichier Serveur Principal (`server.js`)

```javascript
const express = require('express');
const dotenv = require('dotenv');
const productRoutes = require('./routes/productRoutes');

dotenv.config();

const app = express();

// Middleware pour analyser le corps des requ√™tes en JSON
app.use(express.json());

// Sant√© du serveur
app.get('/', (req, res) => {
  res.send('API des produits (Prisma/MySQL) en cours...');
});

// Montage des routes produits
app.use('/api/products', productRoutes);

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  console.log(`Serveur d√©marr√© sur le port ${PORT}`);
});

// Important : Vous n'avez pas besoin de "connecter" la DB comme avec Mongoose,
// le client Prisma g√®re la connexion √† la premi√®re requ√™te.
```

-----


## 6\. Lancement

1.  Assurez-vous que votre serveur MySQL est d√©marr√©.
2.  Lancez l'application :
    ```bash
    node server.js
    ```
    (Ou `nodemon server.js` si vous l'avez install√©)

Votre API CRUD est maintenant fonctionnelle avec **Express**, **Prisma**, et **MySQL** \! üéâ

![CRUD](https://raw.githubusercontent.com/andreasvonfeld/api/refs/heads/main/assets/readme/crud.png)
